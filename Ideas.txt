Next todo:
----------
- Base and basic (string, file) prods, cons
- ui classes and context
- connect 2 tobjects:  tobject(prod) -> tobject2(cons)
- robot, sequencer

Random Ideas:
------------
Environmental superclass for contextual side of things, i.e., non-TObjects.

Tests can invoke other tests, either synchronously or threaded.
Threaded tests can interact with each other.

Actor:  Can be another test or just a set of behaviors
Bound:  How far test objects can reach

Import hints for tests from unit tests defined using googletest, or other framework.

Provide a import/export using protobuf as syntax

Switch to CMake

-----------------------------------------------------------------
Producer, Consumer, Processor interfaces  (short lingo: prod, cons, proc)

Processor isa Producer, Consumer
Proc == ProdCons == Filter == Robot

Prod -> FilterProc -> Cons

Prod1 --\___MergerProc -> Cons
Prod2 --/

Prod -> SplitProc ___/--> Cons1   // either or both paths taken
                     \--> Cons2


ProdCommands --\__--> ConveyerBeltProc --> Cons
ProdObjects  --/         Robots

Robots are used to manipulate the "stream" from outside.  For example, throttle,
  monitor, reject bad items (inspector), duplicate items, modify items, inject
  other info, halt production, queue/buffer items, etc.
---------------------------------------------------------------
About Tobject's:
---------------
Meant to hold a single test, thus the name T(est)Object.
However, that is just the basic usage.  It can also be a container of other 
TObject's.  Or a TObject can hold a single (const) value, such as a return 
value or sort of enum (think handler commands, etc.).

The class structure will probably go to all templates, once the rest is settled down:
        TObject has:
            Tree<TO*> children_;

        Tree<T>
        typedef Iterator<Tree<T> > iterator;

        Iterator<Tree<TO*> >
For now, it is:
        TObjectContainer isa TObject, has:
            TObjectTree* children_;

        TObjectTree : SerializeContract, TObjectIteratorContract, has:
            TObject* value_;
            vector<TObject*> children_;

Need consts for TObjectTrue, TObjectFalse (TOBool), nil, etc.

Here are some possible TObject's:
          Actor, Command, Element, Endpoint, Logic (Process, Fork), Transport
          Notice (Alert, Exception, Message), Lookup (Database, ...)
          Location, Bound
          TestCase, TestBundle, Log, Result

---------------------------------------------------------------
PlugIn factory interface, general extensibility.

? How do final implementation instances get chosen, if multiple exist?
Maybe default behavior is to do a lazy instantiation when parsing the input.
Then first instance resolvable is the winner.  This implies a specific order
of search, i.e., a PATH

Can have "final" state that does not allow (further) plug-ins.
---------------------------------------------------------------
TODO Exception handling

dispositions?
-----------------------------------------------------------------
Should serialization be related to plugin?
-----------------------------------------------------------------
At the base/core level, the UI must be abstracted.  An abstract UI can handle
the following types:
- batch: initial testcase/testsuite is loaded and run. Any prompts come from
         an input file, output goes to file.
- tty:   prompts testcase, inputs, outputs.  finally command prompt.  can also
         prompt along as input is needed.
- term:  tty with addressable cursor, like ncurses
- html:  webforms, tables, pagers, frames(?)
- gui:   regular UI with menu, widgets, panels

The different types vary in their interaction.  But for each piece of data, a
UI would have the following possible interactions:
- input:   prompt directly for info
- output:  display info directly
- push:    prepare output and send to UI
- pull:    call UI hook to get info
- get:     the UI calls this to request info from the model
- put:     the UI calls this to give info to the model

For example, a GUI could send a Cancel or enter new data in a field at any time and
without an explicit prompt (put).  But a tty cannot enter data in a field or chose
Cancel without it being prompted (input).

A stylesheet can optionally be used to adjust the look-n-feel of the UI.  Multiple
styles can exist similar to css.
-----------------------------------------------------------------
