- For if type commands, only allow 2 tobject children, 1 for true other for false.
  These children then contain the set of commands to execute in each case.

TestSuite
    TestCase
        Log
        Loop 3
            Group
                Log
                If
                    Group
                        Log
                        Env
                Else
                    Log
        Log
    TestCase
        ...

Get x from UI
Do p if [ x ]

Info that UI produces can be one at a time (serial) or presented/collected as a whole.
There must be a "done" indicator, i.e., a gui button or confirmation for dumb ui.
Requests for data are pushed on a queue that the ui processes.
Requests are marked as mandatory, default value, "done" action.
Command execution can be suspended if input is required from the ui.
In fact cmdexec should follow a standard pattern of:
- fetch command and check its requirements
- resolve dependencies from available outlets (producers)
- execute command

Next todo:
----------
- TObject type system
- Need to refactor so that base Producer/Consumer methods (that call delegate impl) do
  not usually need to be overridden.
- Serialize variables and outlets (from context?). prods/cons need to use these for operations.
- ui classes, message loop and context
- commands
- connect 2 tobjects:  tobject(prod) -> tobject2(cons)
- robot, sequencer
- more prods, cons (filter, queue, mux, etc.)
  + queueprodcons with subclasses for memory, file, nw, db, etc.
- scenario test: create objects (testcase), deserialize, serialize and run.

- test scenario:
  create a simple test suite, serialize to a filecons
  deserizalize test suite from fileprod
  measure run load vs. number of running threads

Random Ideas:
------------
Environmental superclass for contextual side of things, i.e., non-TObjects.

Context may allow a "_" property for its own base usage.

Tests can invoke other tests, either synchronously or threaded.
Threaded tests can interact with each other.

Actor:  Can be another test or just a set of behaviors
Bound:  How far test objects can reach

Import hints for tests from unit tests defined using googletest, or other framework.

Provide a import/export using protobuf as syntax

Switch to CMake

Add Blob type of StructuredData
- (de)serialize can check if blob is string or SD
- maybe serialize can create a tree of blobs (using members vector) and then flatten

-----------------------------------------------------------------
Producer, Consumer, Processor interfaces  (short lingo: prod, cons, proc)

Processor isa Producer, Consumer
Proc == ProdCons == Filter == Robot

Prod -> FilterProc -> Cons

Prod1 --\__--> MergerProc -> Cons
Prod2 --/

Prod -> SplitProc ___/--> Cons1   // either or both paths taken
                     \--> Cons2


ProdCommands --\__--> ConveyerBeltProc --> Cons
ProdObjects  --/           |
                         Robots

Robots are used to manipulate the "stream" from outside.  For example, throttle,
  monitor, reject bad items (inspector), duplicate items, modify items, inject
  other info, halt production, queue/buffer items, etc.
---------------------------------------------------------------
About Tobject's:
---------------
Meant to hold a single test, thus the name T(est)Object.
However, that is just the basic usage.  It can also be a container of other 
TObject's.  Or a TObject can hold a single (const) value, such as a return 
value or sort of enum (think handler commands, etc.).

The class structure will probably go to all templates, once the rest is settled down:
        TObject has:
            Tree<TO*> children_;

        Tree<T>
        typedef Iterator<Tree<T> > iterator;

        Iterator<Tree<TO*> >
For now, it is:
        TObjectContainer isa TObject, has:
            TObjectTree* children_;

        TObjectTree : SerializeContract, TObjectIteratorContract, has:
            TObject* value_;
            vector<TObject*> children_;

Some TObject's: Command, TestCase, TestSuite
Here are some possible TObject's:
          Predicate
          Actor, Element, Endpoint, Logic (Process, Fork), Transport
          Notice (Alert, Exception, Message), Lookup (Database, ...)
          Location, Bound, Log, Result

---------------------------------------------------------------
PlugIn factory interface, general extensibility.

? How do final implementation instances get chosen, if multiple exist?
Maybe default behavior is to do a lazy instantiation when parsing the input.
Then first instance resolvable is the winner.  This implies a specific order
of search, i.e., a PATH

Can have "final" state that does not allow (further) plug-ins.
---------------------------------------------------------------
TODO Exception handling

dispositions?
-----------------------------------------------------------------
Should serialization be related to plugin?
-----------------------------------------------------------------
At the base/core level, the UI must be abstracted.  An abstract UI can handle
the following types:
- batch: initial testcase/testsuite is loaded and run. Any prompts come from
         an input file, output goes to file.
- tty:   prompts testcase, inputs, outputs.  finally command prompt.  can also
         prompt along as input is needed.
- term:  tty with addressable cursor, like ncurses
- html:  webforms, tables, pagers, frames(?)
- gui:   regular UI with menu, widgets, panels

The different types vary in their interaction.  But for each piece of data, a
UI would have the following possible interactions:
- input:   prompt directly for info
- output:  display info directly
- push:    prepare output and send to UI
- pull:    call UI hook to get info
- get:     the UI calls this to request info from the model
- put:     the UI calls this to give info to the model

For example, a GUI could send a Cancel or enter new data in a field at any time and
without an explicit prompt (put).  But a tty cannot enter data in a field or chose
Cancel without it being prompted (input).

A stylesheet can optionally be used to adjust the look-n-feel of the UI.  Multiple
styles can exist similar to css.
-----------------------------------------------------------------
Blobs could have a serialized/non-serialized form.
There must be some rule, api, mapping, etc. to get from one form to the other.
-----------------------------------------------------------------
Subclassed contexts may become interfaces instead, allowing contexts
to be a collection of interfaces, i.e., multiple behavior.
-----------------------------------------------------------------
